# 动态规划解决俄罗斯套娃信封问题详解

俄罗斯套娃信封问题是一个经典的二维动态规划问题，它要求在一组信封中找到能够嵌套的最大子集。下面我将从问题描述、解题思路、动态规划解法、代码实现到复杂度分析进行全面讲解。

## 问题描述

给定一组信封的宽度和高度对 `envelopes = [[w₁, h₁], [w₂, h₂], ..., [wₙ, hₙ]]`，当一个信封的宽度和高度都比另一个信封大时，可以嵌套进去。求最多能有多少个信封可以嵌套在一起（即俄罗斯套娃）。

**示例**：
- 输入：`[[5,4],[6,4],[6,7],[2,3]]`
- 输出：`3` 
- 解释：最多信封能嵌套成 `[2,3] => [5,4] => [6,7]`

## 解题思路

### 关键观察

1. **排序预处理**：首先对信封进行排序，按照宽度升序排列，如果宽度相同则按高度降序排列。这样做的目的是：
   - 保证在宽度维度上是有序的
   - 相同宽度的信封不会相互嵌套（因为高度降序排列）

2. **转化为最长递增子序列(LIS)问题**：在排序后的高度序列中寻找最长递增子序列，其长度就是能嵌套的最大信封数量。

### 为什么能转化为LIS问题？

- 排序后，我们只需要关注高度维度
- 由于宽度已经有序，只要后面的高度比前面大，就一定能嵌套
- 这样就变成了在一维高度数组中寻找最长递增子序列

## 动态规划解法

### 1. 排序信封

首先对信封进行排序：
- 按宽度升序
- 宽度相同时按高度降序

### 2. 定义状态

`dp[i]` 表示以第 `i` 个信封结尾的最长嵌套序列的长度。

### 3. 状态转移方程

对于每个信封 `i`，我们需要检查所有 `j < i` 的信封：
```
如果 envelopes[j] 能放入 envelopes[i]（即 w_j < w_i 且 h_j < h_i）：
    dp[i] = max(dp[i], dp[j] + 1)
否则：
    dp[i] = 1（至少可以单独作为序列）
```

### 4. 初始化

每个信封至少可以单独作为一个序列：
```
dp[i] = 1 (对于所有i)
```

### 5. 结果提取

最终结果是 `dp` 数组中的最大值。

## 详细实现

### Java代码实现

```java
import java.util.Arrays;
import java.util.Comparator;

public class RussianDollEnvelopes {
    public int maxEnvelopes(int[][] envelopes) {
        if (envelopes == null || envelopes.length == 0) {
            return 0;
        }
        
        // 1. 对信封进行排序
        Arrays.sort(envelopes, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                if (a[0] == b[0]) {
                    return b[1] - a[1]; // 宽度相同，按高度降序
                } else {
                    return a[0] - b[0]; // 按宽度升序
                }
            }
        });
        
        // 2. 提取高度数组
        int[] heights = new int[envelopes.length];
        for (int i = 0; i < envelopes.length; i++) {
            heights[i] = envelopes[i][1];
        }
        
        // 3. 在高度数组中寻找LIS
        return lengthOfLIS(heights);
    }
    
    // 最长递增子序列(LIS)的O(nlogn)解法
    private int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        int size = 0;
        
        for (int num : nums) {
            int i = 0, j = size;
            // 二分查找插入位置
            while (i != j) {
                int mid = (i + j) / 2;
                if (tails[mid] < num) {
                    i = mid + 1;
                } else {
                    j = mid;
                }
            }
            tails[i] = num;
            if (i == size) {
                size++;
            }
        }
        
        return size;
    }
}
```

### 代码解析

1. **排序阶段**：
   - 使用自定义比较器对信封进行排序
   - 首先按宽度升序，宽度相同则按高度降序

2. **提取高度数组**：
   - 排序后只需关注高度维度
   - 将高度提取到一个单独数组中

3. **LIS求解**：
   - 使用O(nlogn)的最长递增子序列算法
   - 维护一个tails数组，其中tails[i]表示长度为i+1的递增子序列的最小末尾值
   - 对于每个元素，用二分查找确定它在tails中的位置

## 复杂度分析

1. **时间复杂度**：
   - 排序：O(nlogn)
   - LIS计算：O(nlogn)
   - 总时间复杂度：O(nlogn)

2. **空间复杂度**：
   - 排序：O(logn)（排序所需的栈空间）
   - LIS计算：O(n)（tails数组）
   - 总空间复杂度：O(n)

## 示例演示

以输入 `[[5,4],[6,4],[6,7],[2,3]]` 为例：

1. **排序后**：
   `[[2,3],[5,4],[6,7],[6,4]]`
   - 按宽度升序
   - 两个[6,...]的信封，高度按降序排列

2. **高度数组**：
   `[3, 4, 7, 4]`

3. **LIS过程**：
   - 初始化 tails = [], size = 0
   - 处理3： tails = [3], size = 1
   - 处理4： 找到插入位置1 → tails = [3,4], size = 2
   - 处理7： 找到插入位置2 → tails = [3,4,7], size = 3
   - 处理4： 找到插入位置1 → tails = [3,4,7], size不变
   - 最终LIS长度为3

## 算法优化

上述实现已经使用了最优的O(nlogn)解法。如果要进一步优化：

1. **合并排序和LIS处理**：可以在排序后直接处理，不单独提取高度数组
2. **使用更快的排序**：对于特定数据分布，可以使用非比较排序
3. **并行处理**：对于非常大的数据集，可以考虑并行化部分计算

## 边界情况处理

1. **空输入**：直接返回0
2. **所有信封相同**：无法嵌套，返回1
3. **完全逆序**：只能选一个，返回1
4. **完全正序**：可以全部嵌套，返回n

## 相关问题

1. **最长递增子序列**：本题的核心子问题
2. **最大矩形面积**：类似的二维问题
3. **盒子嵌套问题**：三维版本的套娃问题

## 总结

俄罗斯套娃信封问题通过巧妙的排序转化为最长递增子序列问题，使得我们可以用高效的动态规划方法解决。关键在于：

1. 正确的排序策略（宽度升序，高度降序）
2. 识别问题可以转化为LIS
3. 应用O(nlogn)的LIS算法

这种"降维"思想（将二维问题转化为一维问题）在许多算法问题中都非常有用，是值得掌握的解题技巧。