# 算法题典型解题思路总结

算法问题虽然千变万化，但常见的解题思路可以归纳为以下几类，每种思路都有其适用场景和基本原理。

## 一、暴力枚举(Brute Force)

### 基本原理
- 尝试所有可能的解，然后选择最优解
- 通常是最直观但效率最低的方法

### 适用场景
- 问题规模很小
- 作为其他优化算法的基准
- 需要验证更复杂算法的正确性

### 典型问题
- 数组所有子集
- 字符串所有排列组合
- 简单搜索问题

## 二、分治法(Divide and Conquer)

### 基本原理
1. 分解：将问题分解为若干子问题
2. 解决：递归解决子问题
3. 合并：将子问题的解合并为原问题的解

### 适用场景
- 问题可以分解为相互独立的子问题
- 子问题的解可以合并为原问题的解
- 子问题的结构与原问题相同

### 典型问题
- 归并排序
- 快速排序
- 大整数乘法
- 汉诺塔问题

## 三、动态规划(Dynamic Programming)

### 基本原理
1. 定义状态：用dp[i]或dp[i][j]表示子问题的解
2. 状态转移方程：建立状态之间的关系
3. 初始化：确定边界条件
4. 计算顺序：按特定顺序计算所有状态
5. 结果提取：从最终状态获取解

### 适用场景
- 问题具有最优子结构
- 存在重叠子问题
- 无后效性（当前状态只与之前状态有关）

### 典型问题
- 背包问题
- 最长公共子序列
- 最短路径问题
- 股票买卖问题
- 编辑距离

## 四、贪心算法(Greedy Algorithm)

### 基本原理
- 每一步都做出当前看起来最优的选择
- 希望局部最优能导致全局最优

### 适用场景
- 问题具有贪心选择性质
- 最优子结构
- 不需要回溯或考虑所有可能性

### 典型问题
- 活动选择问题
- 霍夫曼编码
- 最小生成树(Prim/Kruskal)
- 找零钱问题(特定面值)

## 五、回溯法(Backtracking)

### 基本原理
1. 尝试选择一条路径前进
2. 如果发现当前选择不能得到解，就回溯
3. 尝试其他可能的路径

### 适用场景
- 需要尝试多种可能性
- 问题解空间很大但解的数量有限
- 需要找到所有解或最优解

### 典型问题
- N皇后问题
- 数独求解
- 全排列/组合
- 图的着色问题

## 六、二分查找(Binary Search)

### 基本原理
1. 在有序集合中
2. 每次将搜索范围减半
3. 通过比较中间元素决定下一步搜索方向

### 适用场景
- 数据已排序或可以排序
- 需要快速查找
- 时间复杂度要求O(logn)

### 典型问题
- 有序数组查找
- 寻找旋转排序数组中的最小值
- 平方根计算
- 寻找峰值元素
- 最长递增子序列(优化版)

## 七、双指针(Two Pointers)

### 基本原理
- 使用两个指针以不同速度或方向遍历数据结构
- 通常一个快指针，一个慢指针

### 适用场景
- 线性数据结构(数组/链表)
- 需要同时比较或处理两个元素
- 滑动窗口问题

### 典型问题
- 有序数组的两数之和
- 链表中点/环检测
- 滑动窗口最大值
- 接雨水问题
- 去重或合并有序数组

## 八、广度优先搜索(BFS)和深度优先搜索(DFS)

### 基本原理
- BFS：逐层扩展，使用队列
- DFS：尽可能深地搜索，使用栈(递归)

### 适用场景
- 树/图的遍历
- 最短路径(无权图用BFS)
- 连通分量
- 拓扑排序

### 典型问题
- 二叉树层次遍历(BFS)
- 岛屿数量(DFS)
- 迷宫最短路径(BFS)
- 课程安排(拓扑排序)

## 九、滑动窗口(Sliding Window)

### 基本原理
- 维护一个窗口(通常由两个指针表示)
- 根据条件调整窗口大小和位置
- 在窗口滑动过程中计算所需结果

### 适用场景
- 数组/字符串的子区间问题
- 需要计算连续子序列的性质
- 通常与"最长/最短"、"包含/不包含"等条件相关

### 典型问题
- 无重复字符的最长子串
- 最小覆盖子串
- 长度最小的子数组
- 最大连续1的个数

## 十、位运算(Bit Manipulation)

### 基本原理
- 直接操作数据的二进制表示
- 利用位操作的性质高效计算

### 适用场景
- 需要极致优化的场景
- 处理二进制相关性质
- 状态压缩

### 典型问题
- 只出现一次的数字
- 位计数
- 子集生成(位掩码)
- 两数相加不用加减号

## 十一、并查集(Union-Find/Disjoint Set)

### 基本原理
1. 初始化：每个元素是自己的父节点
2. 查找：找到元素的根(路径压缩优化)
3. 合并：将两个集合合并

### 适用场景
- 动态连通性问题
- 图的连通分量
- 分组问题

### 典型问题
- 朋友圈问题
- 岛屿数量II(动态添加)
- 最小生成树(Kruskal)
- 等式方程的可满足性

## 十二、前缀和与差分数组

### 基本原理
- 前缀和：预处理数组，快速计算区间和
- 差分数组：高效处理区间增减操作

### 适用场景
- 频繁查询区间和
- 频繁进行区间增减操作
- 需要优化区间操作的时间复杂度

### 典型问题
- 区间和检索(不可变数组)
- 航班预订统计
- 子数组和为K
- 二维区域和检索

## 十三、树状数组(Fenwick Tree)和线段树(Segment Tree)

### 基本原理
- 树状数组：高效计算前缀和，支持单点更新
- 线段树：高效处理区间查询和更新

### 适用场景
- 需要频繁查询和更新区间信息
- 常规方法无法满足时间复杂度要求
- 处理动态数据

### 典型问题
- 区间和查询(带更新)
- 区间最大值/最小值
- 逆序对计数
- 日历问题

## 十四、图算法

### 基本原理
- Dijkstra：单源最短路径(无负权边)
- Bellman-Ford：单源最短路径(可处理负权边)
- Floyd-Warshall：所有节点对最短路径
- A*搜索：启发式搜索

### 适用场景
- 路径规划
- 网络路由
- 依赖关系分析
- 资源分配

### 典型问题
- 网络延迟时间
- 课程安排II
- 最小高度树
- 最大概率路径

## 十五、总结对比

| 解题思路 | 时间复杂度 | 空间复杂度 | 典型应用 |
|----------|------------|------------|----------|
| 暴力枚举 | 通常很高 | 通常低 | 小规模问题 |
| 分治法 | O(nlogn) | O(logn)-O(n) | 排序,逆序对 |
| 动态规划 | O(n)-O(n²) | O(n)-O(n²) | 最优子结构问题 |
| 贪心算法 | 通常O(nlogn) | O(1)-O(n) | 局部最优导致全局最优 |
| 回溯法 | 指数级 | O(n) | 组合,排列 |
| 二分查找 | O(logn) | O(1) | 有序数据查找 |
| 双指针 | O(n) | O(1) | 链表,数组 |
| BFS/DFS | O(V+E) | O(V) | 图/树遍历 |
| 滑动窗口 | O(n) | O(1)-O(n) | 子数组/子串 |
| 位运算 | O(1)-O(n) | O(1) | 二进制特性 |
| 并查集 | 接近O(1) | O(n) | 连通性问题 |
| 前缀和 | O(n)预处理 | O(n) | 区间和查询 |
| 线段树 | O(logn)查询/更新 | O(n) | 区间查询更新 |

掌握这些基本解题思路后，面对新的算法问题时，可以：
1. 分析问题特征
2. 匹配适合的解题思路
3. 根据时间/空间复杂度要求选择最优方法
4. 必要时组合多种思路解决问题