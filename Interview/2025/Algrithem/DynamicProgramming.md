### **动态规划（Dynamic Programming, DP）详解**

动态规划是一种通过**将问题分解为重叠子问题**，并利用**记忆化存储**避免重复计算的高效算法设计思想。其核心目标是优化递归或分治解法中的重复计算问题。

---

## **核心思想与原理**
### **1. 基本思想**
- **分治思想**：将原问题分解为若干子问题，递归求解。
- **记忆化存储**：保存子问题的解，避免重复计算（空间换时间）。
- **自底向上或自顶向下**：通过填表（迭代）或备忘录（递归）实现。

### **2. 关键性质**
- **重叠子问题**：子问题被多次重复计算（如斐波那契数列中的 `fib(3)` 被多次调用）。
- **最优子结构**：问题的最优解包含子问题的最优解（如最短路径的子路径也是最短的）。

### **3. 与分治法的区别**
| **维度**       | **动态规划**               | **分治法**               |
|----------------|---------------------------|-------------------------|
| **子问题**     | 重叠且重复计算             | 独立不重叠              |
| **存储**       | 记忆化（表格或备忘录）     | 无记忆化                |
| **典型问题**   | 背包问题、最短路径         | 归并排序、快速排序      |

---

## **基本操作模式**
### **1. 设计步骤**
1. **定义状态**  
   - 明确 `dp[i]` 或 `dp[i][j]` 表示的含义（如 `dp[i]` 表示前 `i` 个元素的最优解）。
2. **确定状态转移方程**  
   - 找到子问题之间的关系（如 `dp[i] = dp[i-1] + dp[i-2]`）。
3. **初始化边界条件**  
   - 设置初始值（如 `dp[0] = 0, dp[1] = 1`）。
4. **选择计算顺序**  
   - 自底向上（迭代填表）或自顶向下（递归+备忘录）。
5. **输出结果**  
   - 返回 `dp[n]` 或其他目标状态。

### **2. 代码框架（以斐波那契为例）**
#### **自底向上（迭代）**
```python
def fib(n):
    dp = [0] * (n + 1)  # 定义状态表
    dp[0], dp[1] = 0, 1  # 初始化
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]  # 状态转移
    return dp[n]
```

#### **自顶向下（递归+备忘录）**
```python
def fib(n, memo={0: 0, 1: 1}):
    if n not in memo:
        memo[n] = fib(n - 1) + fib(n - 2)  # 记忆化存储
    return memo[n]
```

### **3. 常见优化技巧**
- **空间压缩**：若 `dp[i]` 仅依赖前几个状态，可用滚动数组（如斐波那契中仅保留 `dp[i-1]` 和 `dp[i-2]`）。
- **状态复用**：如背包问题中二维数组优化为一维数组。

---

## **经典问题与使用场景**
### **1. 一维DP问题**
- **场景**：线性序列上的最优解。  
- **示例**：  
  - **斐波那契数列**：`dp[i] = dp[i-1] + dp[i-2]`。  
  - **爬楼梯**（LeetCode 70）：每次爬1或2阶，求到第 `n` 阶的方法数。  
  - **最大子数组和**（LeetCode 53）：`dp[i] = max(nums[i], dp[i-1] + nums[i])`。

### **2. 二维DP问题**
- **场景**：涉及两个维度（如字符串、矩阵）。  
- **示例**：  
  - **最长公共子序列**（LCS）：  
    ```python
    dp[i][j] = dp[i-1][j-1] + 1 if s1[i] == s2[j] else max(dp[i-1][j], dp[i][j-1])
    ```  
  - **编辑距离**（LeetCode 72）：增、删、替换的最小操作数。  
  - **矩阵路径问题**（如最小路径和）。

### **3. 背包问题**
- **0-1背包**：物品不可分割，`dp[i][j]` 表示前 `i` 个物品在容量 `j` 下的最大价值。  
  ```python
  dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)  # w为重量，v为价值
  ```  
- **完全背包**：物品可重复选取（如零钱兑换，LeetCode 322）。

### **4. 状态机DP**
- **场景**：状态转移受多条件约束。  
- **示例**：  
  - **买卖股票问题**（如LeetCode 121、123）：`dp[i][k][0/1]` 表示第 `i` 天、交易 `k` 次、是否持有股票的最大利润。  
  - **打家劫舍**（LeetCode 198）：`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`。

### **5. 区间DP**
- **场景**：对区间或子序列的操作（如合并石子、回文分割）。  
- **示例**：  
  - **最长回文子串**（LeetCode 5）：  
    ```python
    dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]
    ```  

---

## **适用条件总结**
1. **问题可分解**：存在子问题且能通过组合子问题得到原问题解。  
2. **重叠子问题**：子问题被多次重复计算。  
3. **最优子结构**：全局最优解依赖局部最优解。  

---

## **动态规划 vs 贪心算法**
| **维度**       | **动态规划**               | **贪心算法**           |
|----------------|---------------------------|-----------------------|
| **解的性质**   | 全局最优                  | 局部最优（可能非全局）|
| **计算方式**   | 存储子问题解              | 每一步做当前最优选择  |
| **适用场景**   | 子问题重叠且需精确解      | 问题具有贪心选择性质  |

---

## **实战技巧**
1. **画状态转移表**：帮助理解 `dp` 表的填充过程（如二维矩阵）。  
2. **从暴力递归入手**：先写递归再优化为DP。  
3. **注意边界条件**：如 `dp[0]` 或空输入的特殊情况。  

动态规划通过**系统化地存储中间结果**，将指数级复杂度（如暴力递归）优化为多项式级（如 O(n²)），是解决复杂优化问题的核心方法。